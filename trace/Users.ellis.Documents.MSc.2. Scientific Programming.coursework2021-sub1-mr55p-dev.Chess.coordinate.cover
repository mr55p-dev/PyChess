    1: from itertools import repeat
    1: from typing import List, Tuple, Union
    1: import math
    1: import Chess.constants as cons
    1: from Chess.exceptions import InvalidFormat, InvalidVector
       
       
    2: class Vec:
    1:     VALID_RANGE = range(-8, 9)
       
    1:     def __init__(self, i: int, j: int) -> None:
 2988:         if i not in self.VALID_RANGE: raise InvalidVector
 2988:         if j not in self.VALID_RANGE: raise InvalidVector
       
 2988:         self._i: int = i
 2988:         self._j: int = j
       
    1:     def __repr__(self) -> str:
               return str((self._i, self._j))
       
    1:     def __eq__(self, o) -> bool:
               return self._i == o.i and self._j == o.j
       
    1:     def __ne__(self, o) -> bool:
               return self._i != o.i and self._j != o.j
       
    1:     def __add__(self, o) -> 'Vec':
               return Vec(self._i + o.i, self._j + o.j)
       
    1:     def __sub__(self, o) -> 'Vec':
               return Vec(self._i - o.i, self._j - o.j)
       
    1:     def __mul__(self, scalar) -> 'Vec':
 1692:         return Vec(self._i * scalar, self._j * scalar)
       
    1:     @property
    1:     def i(self) -> int:
 1692:         return self._i
       
    1:     @property
    1:     def j(self) -> int:
 1692:         return self._j
       
       
    2: class Position:
    1:     """
               Wrapper for the positions on a chess board.
               Can convert to/from algebraic ("A1", "B2"..."H8") notation.
       
           :param pos str|tuple: Either a string representing
                                   algebraic notation, or a set
                                   of i and j coordinates as a
                                   tuple or list.
               :attr coord: [0-7, 0-7]
               :attr algebraic: "[A-H][0-7]"
       
           rank and file are internally represented as `i` and `j` to avoid some confusion,
           relating them to matrix notation feels more familiar.
           - consider implementing __slots__
           """
    1:     _TYPE_ALG = str
    1:     _TYPE_CAR = Tuple[int, int]
    1:     _TYPE_INI = Union[str, Tuple[int, int]]
       
    1:     def __init__(self, pos: _TYPE_INI) -> None:
               """__init__.
       
               :param self:
               :param pos str|tuple: Either a string representing
                                       algebraic notation, or a set
                                       of i and j coordinates as a
                                       tuple or list.
               :rtype: None
               """
 1734:         if isinstance(pos, str):
    3:             self._from_algebraic(pos)
 1731:         elif isinstance(pos, tuple):
 1731:             self._from_grid(pos)
       
 1734:         self._validate_position()
       
    1:     def _from_algebraic(self, pos: _TYPE_ALG) -> None:
    3:         if len(pos) != 2: raise InvalidFormat
    3:         file = pos[0]
               # convert rank to numeric
    3:         try:
    3:             rank = int(pos[1])
               except ValueError:
                   raise InvalidFormat
    3:         rank -= 1
               # convert file to numeric
    3:         try:
    3:             file = cons.REV_FILES[file]
               except KeyError:
                   raise InvalidFormat
       
    3:         self._i = rank
    3:         self._j = file
       
    1:     def _from_grid(self, pos: _TYPE_CAR) -> None:
               """Load in rows and columns from a tuple"""
 1731:         self._i = pos[0]
 1731:         self._j = pos[1]
       
    1:     def _validate_position(self) -> bool:
               """Validate that the current position is on the board"""
 1734:         if self._i not in cons.CART_COORD: raise InvalidFormat
 1374:         if self._j not in cons.CART_COORD: raise InvalidFormat
 1230:         return True
       
    1:     def __repr__(self) -> str:
               """Reproduce the vector in algebraic notation"""
               return self.algebraic
       
    1:     def __eq__(self, o) -> bool:
               """Support testing equality between two instances of this class"""
  849:         if isinstance(o, Position): return self.algebraic == o.algebraic
               else: return self.__hash__() == o
       
    1:     def __ne__(self, o: 'Position') -> bool:
               """Support testing equality between two instances of this class"""
    8:         assert isinstance(o, Position)
    8:         return self.algebraic != o.algebraic
           
    1:     def __add__(self, o: Vec) -> 'Position':
               """Support addition by a vector Vec"""
 1692:         return Position((self._i + o.i, self._j + o.j))
       
    1:     def __sub__(self, o: Union[Vec, 'Position']) -> 'Position':
               """Support subtraction by a vector Vec"""
               return Position((self._i - o.i, self._j - o.j))
       
    1:     def path_to(self, o: 'Position') -> List['Position']:
               """path_to. Calculates the squares from this position to another position.
               Given `a.path_to(b)` the position of `a` will be included, but not the position of `b`
       
               :param self:
               :param o:
               :rtype: List['Position']
               """
    6:         sign = lambda x: int(math.copysign(1, x))
    2:         di = o._i - self._i
    2:         dj = o._j - self._j
    2:         ri = range(self._i, o._i, sign(di))
    2:         rj = range(self._j, o._j, sign(dj))
               #Â If there is a straight or diagonal path between the pieces then give that
    2:         if len(ri) == len(rj): 
                   return [Position((i, j)) for i, j in zip(ri, rj)]
    2:         elif len(ri) == 0:
   11:             return [Position((i, j)) for i, j in zip(repeat(self._i), rj)]
               elif len(rj) == 0:
                   return [Position((i, j)) for i, j in zip(ri, repeat(self._j))]
               # Else just give the original location (used for the path of knights)
               else: return [Position((self._i, self._j))]
       
    1:     def __hash__(self) -> int:
               """Generate a hash of the position
               allows positions to be the key of the _loc_map dict in 
               `Game`"""
 1589:         return 10*self._i + self._j
       
    1:     @property
    1:     def algebraic(self) -> str:
               """algebraic.
               :param self:
               :rtype: str
               """
 1714:         return cons.FILES[self._j] + str(self._i + 1)
       
    1:     @property
    1:     def grid(self) -> Tuple[int, int]:  
               return self._i, self._j 
       
    1:     @property
    1:     def i(self) -> int:
               return self._i
       
    1:     @property
    1:     def j(self) -> int:
               return self._j
       
       
    2: class Move():
    2:     def __init__(self, 
    1:                  start: Position, 
    1:                  end: Position, 
    1:                  takes: bool,
    1:                  castle: str = ''                
                        ):
               self.__start = start
               self.__end = end
               self.__takes = takes
               self.__is_castle = castle
       
    1:     @property
    1:     def start(self) -> Position:
               return self.__start
       
    1:     @property
    1:     def end(self) -> Position:
               return self.__end
       
    1:     @property
    1:     def takes(self) -> bool:
               return self.__takes
       
    1:     @property
    1:     def is_castle(self) -> str:
               return self.__is_castle
