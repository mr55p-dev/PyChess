    1: from enum import Enum, auto
    1: from collections.abc import MutableMapping
    1: from typing import Any, Callable, Dict, Iterator, List, Optional
       
    1: from Chess.coordinate import Position
    1: from Chess.pieces import King, Piece
       
       
    2: class ResultKeys(Enum):
    1:     passive = auto()
    1:     capture = auto()
    1:     attack = auto()
    1:     defend = auto()
    1:     pin = auto()
       
       
    2: class BaseResult(MutableMapping):
    1:     @staticmethod
    1:     def flatten(l: List[List[Any]]) -> List[Any]:
  116:         return [j for i in l for j in i]
       
       
    2: class Result(BaseResult):
    1:     _KT = ResultKeys
    1:     _VT = List[Position]
       
    1:     def __init__(self, res: Dict[_KT, _VT] = {}) -> None:
 2135:         self.__store = {k: [] for k in ResultKeys}
  305:         if res:
   17:             self.__store = res
       
    1:     def __delitem__(self, v: _KT) -> None:
               del self.__store[v]
       
    1:     def __getitem__(self, k: _KT) -> _VT:
 1112:         return self.__store[k]
       
    1:     def __setitem__(self, k: _KT, v: _VT) -> None:
   21:         self.__store[k] = v
       
    1:     def __iter__(self) -> Iterator[_KT]:
               return iter(self.__store)
       
    1:     def __len__(self) -> int:
               return len(self.__store)
       
    1:     def filter(self, key: ResultKeys, test: Callable) -> 'Result':
   32:         filtered = [i for i in self.__store[key] if test(i)]
  112:         res = Result({k: self.__store[k] for k in self.__store})
   16:         res[key] = filtered
   16:         return res
           
    1:     def filter_valid(self, test: Callable) -> 'Result':
               res = Result({k: self.__store[k] for k in self.__store})
               res[ResultKeys.passive] = [i for i in self.__store[ResultKeys.passive] if test(i)]
               res[ResultKeys.capture] = [i for i in self.__store[ResultKeys.capture] if test(i)]
               return res
       
    1:     def filter_all(self, test: Callable) -> 'Result':
    7:         res = Result({k: self.__store[k] for k in self.__store})
    6:         for k in self.__store:
   15:             res[k] = [i for i in self.__store[k] if test(i)]
    1:         return res
       
    1:     @property
    1:     def has_moves(self) -> bool:
               for k in self.__store:
                   if self.__store[k]:
                       return True
               return False
       
    1:     @property
    1:     def has_passive_or_capture(self) -> bool:
               if self.__store[ResultKeys.capture] or self.__store[ResultKeys.passive]:
                   return True
       
    2: class ResultSet(BaseResult):
    1:     _KT = Piece
    1:     _VT = Result
       
    1:     def __init__(self, mapping: Dict[_KT, _VT] = {}) -> None:
   19:         self.__store = dict() 
   19:         if mapping:
    1:             self.__store = mapping
       
    1:     def __len__(self) -> int:
               return len(self.__store)
       
    1:     def __delitem__(self, v: _KT) -> None:
               del self.__store[v]
       
    1:     def __getitem__(self, k: _KT) -> _VT:
   18:         return self.__store[k]
       
    1:     def __setitem__(self, k: _KT, v: _VT) -> None:
  289:         self.__store[k] = v
       
    1:     def __iter__(self) -> Iterator[_KT]:
    2:         return iter(self.__store)
       
    1:     @property
    1:     def all_valid(self) -> List[Position]:
   18:         result_passive = self.flatten([result[ResultKeys.passive] for result in self.__store.values()])
   18:         result_capture = self.flatten([result[ResultKeys.capture] for result in self.__store.values()])
    1:         return result_passive + result_capture
       
    1:     @property
    1:     def all_passive(self) -> List[Position]:
               return self.flatten([result[ResultKeys.passive] for result in self.__store.values()])
       
    1:     @property
    1:     def all_capture(self) -> List[Position]:
               return self.flatten([result[ResultKeys.capture] for result in self.__store.values()])
       
    1:     @property
    1:     def all_defend(self) -> List[Position]:
   18:         return self.flatten([result[ResultKeys.defend] for result in self.__store.values()])
       
    1:     @property
    1:     def all_attack(self) -> List[Position]:
   18:         return self.flatten([result[ResultKeys.attack] for result in self.__store.values()])
       
    1:     @property
    1:     def all_pins(self) -> List[Position]:
               return self.flatten([result[ResultKeys.pin] for result in self.__store.values()])
       
    1:     @property
    1:     def king(self) -> Result:
               for k in self.__store:
                   if isinstance(k, King):
                       return self.__store[k]
               raise IndexError("There is no king in this result set")
       
    1:     def lookup_pin(self, pin_loc: Position) -> Optional[Piece]:
  255:         for piece in self.__store:
  240:             if pin_loc in self.__store[piece][ResultKeys.pin]:
                       return piece
   15:         return None
       
    1:     def filter_by_move_type(self, key: ResultKeys , test: Callable) -> 'ResultSet':
   18:         return ResultSet({k: self.__store[k].filter(key, test) for k in self.__store})
       
    1:     def filter_all_by_value(self, test: Callable) -> 'ResultSet':
               return ResultSet({k: self.__store[k].filter_all(test) for k in self.__store}) 
       
    1:     def filter_all_by_key(self, test: Callable) -> 'ResultSet':
               return ResultSet({k: self.__store[k] for k in self.__store if test(k)})
       
    1:     def clear_set(self, pieces: List[Piece]) -> None:
               for k in self.__store:
                   if k in pieces:
                       self.__store[k] = Result()
               
    1:     def clear(self) -> None:
               for k in self.__store:
                   self.__store[k] = Result()
               
           # This should be redundant
    1:     def lookup_kind(self, kind_str: str) -> 'ResultSet':
               pieces = [k for k in self.__store if k.kind == kind_str]
               empty_set = ResultSet()
               for k in self.__store:
                   if k.kind == kind_str:
                       empty_set[k] = self.__store[k]  # type: ignore
               return empty_set
       
       
